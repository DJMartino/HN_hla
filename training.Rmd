---
title: "hla_analysis"
author: "David Martino"
date: "27 July 2015"
output: html_document
---
###stage 1: preparation of data###

```{r load packages, include=FALSE}
Sys.setenv(http_proxy="http://proxy1.ap.webscanningservice.com:3128") 
library(reshape2)
library(plyr)
source('/Users/david/Documents/projects/healthnuts/hla/imputationData/imp2.v2/HN_hla/hlaAnalysis_ancestry.R')
setwd("/Users/david/Documents/projects/healthnuts/hla/imputationData/imp2.v2/HN_hla/data")
```

```{r read in data, include=FALSE}
rawdata=read.delim('HN2.hla.csv',header=T,sep=",",colClasses = c(Allele='character'))
imputes=read.delim('HN2.hla.txt',header=T,sep="")
phenotypes=read.delim('PEANUT_ALLERGY.4PLINK.phen',sep="",header=T)
phenotypes$Phenotype=ifelse(phenotypes$PEANUT_ALLERGY==2,'cases', 
             ifelse(phenotypes$PEANUT_ALLERGY==1,'controls', 'missing'))
```

```{r data summaries}
dat=merge(rawdata,phenotypes,by.x="IndividualID",by.y='IID')
dat=dat[!dat$Phenotype=='missing',]
dat$ANCESTRY=as.factor(as.character(dat$ANCESTRY))

table(dat$Phenotype,dat$ANCESTRY)
```

###stage2: Summaries and data structures to represent HLA allele data.###

Counts the number of cases and controls for each allele.
Creates a matrix representation which can be used for regression modelling.
Value is a list includes 'alleleVars' 'haplotypeCounts' 'modelData' 'dataMatrix'

The input should be a data frame obtained by reading IMP1 or IMP2 imputation
calls, with an extra column attached called "Phenotype" which takes two
possible values: "cases" and "controls".

```{r initiate data structure}
counts=hlaCounts(dat,callThreshold=0.7)
```

####extract the haplotype counts####
```{r haplotype counts}
hapCount=counts$haplotypeCounts

#Filter to remove alleles with low confidence calls (below threshold). 
foo=grep('NA',hapCount$Allele)
hapCount=hapCount[-foo,]

```

####check concordance beetween allele frequnecy cases versus controls####
```{r allelefreq cases v controls, fig.width=5, fig.height=5}
library(car)
z.cols <- cut(as.numeric(hapCount$ANCESTRY), 3, labels = c("red", "blue", "forest green"))
plot(hapCount$alleleFreq.cases,hapCount$alleleFreq.controls, cex=0.8,pch=19, xlab= 'allele frequency cases', ylab= 'allele frequency controls', main = 'Sanity Check', col = as.character(z.cols))
legend(0,0.8, unique(hapCount$ANCESTRY),pch=19, col = as.character(unique(z.cols)))
with(hapCount, dataEllipse(hapCount$alleleFreq.cases, hapCount$alleleFreq.controls, ANCESTRY, level=0.95, fill=TRUE, fill.alpha=0.1, plot.points=FALSE, add=TRUE,col=levels(z.cols), center.pch="+"))
coord=c(36, 230, 235, 242, 243, 284, 286, 332, 351)
with(hapCount[coord,],text(alleleFreq.cases,alleleFreq.controls,Allele, cex=0.8))
```

####simple barplot vizualisation####
```{r barplot freqs, fig.width=7, fig.height=7, results='hide'}
repbarplot <- function(genes) {
    hapcount1 <- hapCount[hapCount$Gene == genes,]
    barplot(hapcount1[,8],col = "white", border ="blue",ylim=range(hapcount1[,8], hapcount1[,7]))
    barplot(hapcount1[,7], col = "white", border = "red", add = TRUE,names.arg = hapcount1$Allele
    ,cex.names=0.7, las=2,yaxt="n", main = print(unique(hapcount1$Gene)))
    legend('topright',c('case','control'),pch=0,col=c('red', 'blue'))
}

par(mfrow = c(4, 2))
par(mar = c(4, 2, 2, 4))
sapply(unique(hapCount$Gene),function(x) repbarplot(x))
```

####Plot allele freq controls by ancestry####
```{r pop strat controls, fig.width=10, fig.height=10}
library(ggplot2)
ggplot(hapCount, aes(Allele, alleleFreq.controls, col=ANCESTRY)) + geom_point() + facet_wrap(~Gene, scale="free_y") + theme(axis.text.x=element_text(angle=45, hjust=1, size=5),legend.position="top")
```

```{r create BIGDAWG compatible data structure, include=FALSE}
asians=subset(dat, ANCESTRY=="Asian")
europeans=subset(dat, ANCESTRY=="European")
admixed=subset(dat, ANCESTRY=="MixedEuropeanAsian")

rda=dcast(asians, IndividualID + Phenotype ~ Gene + Chromosome, value.var = "Allele")
rda$Phenotype=ifelse(rda$Phenotype == 'controls', 0,1)
rda=as.data.frame(apply(rda, 2, function(y) gsub("(\\d\\d)(\\d\\d)", "\\1:\\2", y)))
colnames(rda)=c("subjectID","Disease", rep(c("A","B","C","DPA1","DPB1","DQA1","DQB1","DRB1"),each=2))

rde=dcast(europeans, IndividualID + Phenotype ~ Gene + Chromosome, value.var = "Allele")
rde$Phenotype=ifelse(rde$Phenotype == 'controls', 0,1)
rde=as.data.frame(apply(rde, 2, function(y) gsub("(\\d\\d)(\\d\\d)", "\\1:\\2", y)))
colnames(rde)=c("subjectID","Disease", rep(c("A","B","C","DPA1","DPB1","DQA1","DQB1","DRB1"),each=2))

rdm=dcast(admixed, IndividualID + Phenotype ~ Gene + Chromosome, value.var = "Allele")
rdm$Phenotype=ifelse(rdm$Phenotype == 'controls', 0,1)
rdm=as.data.frame(apply(rdm, 2, function(y) gsub("(\\d\\d)(\\d\\d)", "\\1:\\2", y)))
colnames(rdm)=c("subjectID","Disease", rep(c("A","B","C","DPA1","DPB1","DQA1","DQB1","DRB1"),each=2))

```

####test for HWE####
```{r initiate a BIGDAWG analysis, include=TRUE}
library(BIGDAWG)
write.table(rda,file='bigdawgtest_asians.txt',sep='\t',row.names=F,col.names=T)
write.table(rde,file='bigdawgtest_europeans.txt',sep='\t',row.names=F,col.names=T)
write.table(rdm,file='bigdawgtest_admixed.txt',sep='\t',row.names=F,col.names=T)
BIGDAWG(Data="bigdawgtest_asians.txt", HLA=T, All.Pairwise=F,Run.Tests = "HWE")
BIGDAWG(Data="bigdawgtest_europeans.txt", HLA=T, All.Pairwise=F,Run.Tests = "HWE")
BIGDAWG(Data="bigdawgtest_admixed.txt", HLA=T, All.Pairwise=F,Run.Tests = "HWE")
``` 

####create genotype matrix####

#set allele posteriors to zero if less than 0.7

```{r initiate haplo.stats matrix}
library(haplo.stats)
#dat$Allele=ifelse(dat$Posterior < 0.7, 0, dat$Allele)
rd=dcast(dat, IndividualID + GENDER + ANCESTRY + Phenotype ~ Gene + Chromosome, value.var = "Allele")
colnames(rd)[5:20]= gsub("_", ".a",colnames(rd)[5:20])
head(rd)
```

###Global haplotype score sliding###
Identify subhaplotypes from a group of loci using association testing
```{r}
y.bin <- 1*(rd$Phenotype=="cases")

x.ma <- cbind(rd$ANCESTRY, rd$GENDER)

genotypes=rd[,-c(1:4)]
rownames(genotypes)=rd$IndividualID
genotypes=genotypes[,c(1,2,5,6,3,4,15,16,11,12,13,14,7,8,9,10)]

label=c("A","C","B","DRB1","DQA1","DQB1","DPA1","DPB1")

score.slide.bin <- haplo.score.slide(y.bin, genotypes, trait.type="binomial",
  x.adj = x.ma, skip.haplo = 0.01,haplo.effect="additive",miss.val=0,
  locus.label=label,simulate=TRUE,
  sim.control=score.sim.control(min.sim=200,max.sim=500,verbose=F))
 
plot.haplo.score.slide(score.slide.bin)
```

####trend test####
```{r}
tt=trendTest.hlaAnalysis(counts)
tt[tt$p.trend<0.05,]
foo=which(tt[,2]<0.05)
tt.up=tt[foo,]
tt.up
```

trendTestSingle('DPB1.0301',counts)

####filter to class II genes####
```{r subset data}
genotypes=rd[,c(11:20)]
rownames(genotypes)=rd$IndividualID
label=sort(unique(dat$Gene))
classII=as.character(label[-c(1:3)])
head(genotypes)
```

####Compute the number of loci with 0,1 or 2 missing alleles and count the number of potential haplotype pairs that are consistent with the observed data. Remove missingness.####
```{r}
###Preview missing data###
geno.desc <- summaryGeno(genotypes, miss.val=c(0,NA))

#Sum of missing alleles per individual
miss.all <- which(geno.desc[,4] > 100000)
geno.updated <- genotypes[-miss.all,]
```

###Haplotype frequency estimation###

computes maximum likelihood estimates of haplotype probabilities. Posterior probabilities of haplotype pairs for each subject are also computed.Haplotype probabilities by group are also computed.
```{r compute haplotype probs}
seed <- c(17, 53, 1, 40, 37, 0, 62, 56, 5, 52, 12, 1)
set.seed(seed)

save.em <- haplo.em(geno=geno.updated, locus.label=classII, miss.val=c(NA),
  control = haplo.em.control(n.try = 40, insert.batch.size=2))

print(save.em,nlines=20)
summary(save.em,show.haplo=TRUE,nlines=20)
```

####Compute haplotype frequencies according to each level of grouping variable.#####
```{r compute group frequencies}
y.bin = y.bin[-miss.all]
group.bin <- haplo.group(y.bin, geno.updated, locus.label=as.character(classII), miss.val=0)
print(group.bin, nlines=10)
```

###test assocaition between haplotypes and phenotype using EM method of Schaid et al###

Hapltype effects modelled as 'additive' adjusting for gender and ancestry
p-values computed by permutation of traits and covariates.
Computes the maximum likelihood estimates of the haplotype frequencies and the posterior probabilities of the pairs of haplotypes for each subject using an EM algorithm. The algorithm begins with haplotypes from a subset of the loci and progressively discards those with low frequency before inserting more loci. The process is repeated until haplotypes for all loci are established. The posterior probabilities are used to compute the score statistics for the association of (ambiguous) haplotypes with traits. 

```{r initiate EM algorithm}
x.ma <- cbind(rd$ANCESTRY, rd$GENDER)
x.ma=x.ma[-miss.all,]
  score.bin <- haplo.score(y.bin, geno.updated, trait.type="binomial",
  x.adj = x.ma, skip.haplo = 0.01,haplo.effect="additive",miss.val=0,
  locus.label=as.character(classII),simulate=TRUE,
  sim.control=score.sim.control(min.sim=200,max.sim=500,verbose=F))

print.haplo.score(score.bin, nlines=20)
```

####merge stats with haplo freq by group####
```{r merge stats with freqs}
merge.bin <- haplo.score.merge(score.bin, group.bin)
print.haplo.score.merge(merge.bin,order.by='p.val')
```

###Case control analysis unadjusted###
```{r case control, warning=FALSE}
cc.hla <- haplo.cc(y=y.bin, geno=geno.updated, locus.label = classII,
 control=haplo.glm.control(haplo.freq.min=.01))
print(cc.hla, nlines=20, digits=2)
```


###Binomial regression models###
```{r binomial regression, warning=FALSE}
geno.glm <- setupGeno(geno.updated, miss.val=c(0,NA), locus.label=classII)
glm.data <- data.frame(geno.glm, ancestry=rd$ANCESTRY[-miss.all], gender=rd$GENDER[-miss.all], y.bin=y.bin)

#weight cases to pop prevalence of 3%
weights= ifelse(y.bin==1,0.03,1)

fit.bin <- haplo.glm(y.bin ~ ancestry + gender + geno.glm, family = binomial,
 data=glm.data, na.action = "na.geno.keep",
 locus.label=classII,weights=weights,
 control = haplo.glm.control(haplo.effect='additive',haplo.freq.min = .01))

summary(fit.bin)
```

dat=merge(rawdata,phenotypes,by.x="IndividualID",by.y='IID')
dat=dat[!dat$Phenotype=='missing',]
dat$ANCESTRY=as.factor(as.character(dat$ANCESTRY))

haplotypeCounts <- dcast(melt(dat, measure.vars = "Posterior"),
                    Gene + Allele ~ Phenotype,
                    length)
                    
haplotypeCounts <- transform(haplotypeCounts, total = cases + controls)

colnames(haplotypeCounts)[3:5] <- paste0("numHap.",colnames(haplotypeCounts)[3:5])

res <- ddply(haplotypeCounts, .(Gene),
                 mutate,
                 alleleFreq.controls = numHap.controls / sum(numHap.controls),
                 alleleFreq.cases    = numHap.cases    / sum(numHap.cases   ),
                 alleleFreq.total    = numHap.total    / sum(numHap.total   ))


#Filter to remove alleles with less than 1% representation in the population. 
toremove=res$alleleFreq.total<0.01
hapCount=res[toremove=='FALSE',]

hapCount$Allele<-paste(hapCount$Gene, hapCount$Allele, sep = ".")

##Names of Alleles to analyse###
alleles.hf=hapCount$Allele

# Names of all of the genes in the dataset.
genes <- sort(unique(dat$Gene))

# Combine gene and allele names.
dat$G.Allele <- paste(dat$Gene, dat$Allele, sep = ".")

# Complie data set.
dataMatrix <- dcast(melt(dat, measure.vars = "Posterior"),
                       IndividualID + ANCESTRY +GENDER + Phenotype ~ G.Allele,
                       length)

df=as.data.frame(dataMatrix[,-(1:4)])
foo=colnames(df)%in%alleles.hf
keep=df[,which(colnames(df)%in%alleles.hf)]
modelData=cbind(dataMatrix[,c(1:4)],keep)

#Define response
pheno=as.factor(modelData$Phenotype)

#Define the genes to test
genes=sort(unique(dat$Gene))

#Container for the result
result <- vector("list")

#Fit logistic regression model over each gene
for (gene in genes) {
  allVars         <-  grep(paste0(gene,"."), names(modelData),fixed=TRUE)
  df              <-  modelData[, c(2,3,allVars)]
  fit.all[[gene]] <-  glm(pheno~., df,family = "binomial")
  result[[gene]]  <- summary(fit.all[[gene]])
}

result  

fit.glm0 <-  glm(as.factor(Phenotype)~1,data = modelData, family='binomial')
fit.glm1 <-  glm(as.factor(Phenotype)~ANCESTRY+GENDER,data = modelData, family='binomial')
fit.glm2 <-  glm(as.factor(Phenotype)~ANCESTRY+GENDER+DQB1.0202, data = modelData, family='binomial')

anova(fit.glm0,fit.glm1,fit.glm2,test="Chisq")

# OR estimate and Wald test p-value.
 m.fit <- coef(summary(fit.glm2))[, -3, drop = FALSE]
colnames(m.fit) <- c("logOR", "se.logOR", "p.wald")

# 95% CI for the OR.
ci <- exp(confint.default(fit.glm2))

#package up
table=cbind(m.fit,ci)

#print to screen
table
